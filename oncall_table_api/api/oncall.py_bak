#!/usr/bin/env python
# -*- coding: utf-8 -*-

import time
import random
import datetime
import calendar

import django.db
from dateutil.parser import parse
from datetime import timedelta
from api.models import Users, OnCallSchedule, DrawLots


class scheduler:
    def __init__(self, month: str):
        # 月份
        self.month = month

        # 抽签id
        self.draw_lots_user_ids = []

        # 当前轮到谁了
        self.current_draw_lots_user_id = None

        # 当前偏移量
        self.position = 0

    @staticmethod
    def get_next_draw_lots_id(draw_list, position):
        if len(draw_list) <= position:
            position = 0
        return position, draw_list[position]

    @staticmethod
    def get_month_dates(date_str: str):
        # 将日期字符串转换为datetime对象
        date_obj = datetime.datetime.strptime(date_str, '%Y-%m')

        # 获取年份和月份
        year = date_obj.year
        month = date_obj.month

        # 获取该月份的天数
        _, num_days = calendar.monthrange(year, month)

        # 生成该月份的所有日期
        dates = []
        for day in range(1, num_days + 1):
            date = datetime.date(year, month, day)
            dates.append(date.strftime('%Y-%m-%d'))

        return dates

    @staticmethod
    def get_draw_lots_by_effective(date: datetime) -> DrawLots:
        return DrawLots.objects.filter(
            effective_date__lte=date
        ).last()

    @staticmethod
    def gen_oncall_info(future_obj, day):
        return {
            "user_id": future_obj.user.id,
            "username": future_obj.user.username,
            "name": future_obj.user.name,
            "email": future_obj.user.email,
            "phone": future_obj.user.phone,
            "date": day,
            "type": future_obj.type,
        }

    @staticmethod
    def get_dates_between(start_date_str, end_date_str):
        start_date = datetime.datetime.strptime(start_date_str, "%Y-%m-%d")
        end_date = datetime.datetime.strptime(end_date_str, "%Y-%m-%d")
        dates = [start_date + timedelta(days=x) for x in range(1, (end_date - start_date).days + 1)]
        date_strings = [date.strftime("%Y-%m-%d") for date in dates]
        return date_strings

    @staticmethod
    def calculate_future_data(day, user_obj):
        return {
            "user_id": user_obj.id,
            "username": user_obj.username,
            "name": user_obj.name,
            "email": user_obj.email,
            "phone": user_obj.phone,
            "date": day,
            "type": 0
        }

    def calculate_history_data(self, day, user_obj):
        history_oncall_obj = OnCallSchedule.objects.filter(
            on_call_date=day
        ).first()

        if not history_oncall_obj:
            OnCallSchedule(
                user=user_obj,
                on_call_date=day,
            ).save()
        obj = OnCallSchedule.objects.filter(on_call_date=day).first()
        return self.gen_oncall_info(obj, day)

    def calculate_engine(self, draw_lots_obj, history_start_day,
                         end_day, draw_lots_list,
                         start_lots_id, callback_func,
                         pre_position=0):
        start_day_format = history_start_day.strftime("%Y-%m-%d")
        end_day_format = end_day.strftime("%Y-%m-%d")
        day_list = self.get_dates_between(start_day_format, end_day_format)
        position = draw_lots_list.index(start_lots_id) + 1
        if position == len(draw_lots_list):
            position = 0
        if (position + pre_position) >= len(draw_lots_list):
            position = (position + pre_position) - len(draw_lots_list)
            print(position, "<-------")
        else:
            position += pre_position
        if pre_position > 0:
            pre_position = position
        result = []

        if len(day_list) == 0:
            position, user_id = self.get_next_draw_lots_id(draw_lots_list, position)
            user_obj = Users.objects.filter(id=user_id).first()
            result.append(callback_func(end_day_format, user_obj))
            return result
        for day in day_list:
            new_draw_lots_obj = DrawLots.objects.filter(
                effective_date__lte=parse("%s 00:00:00" % day)
            ).order_by("effective_date").last()
            if new_draw_lots_obj and new_draw_lots_obj.id != draw_lots_obj.id:
                draw_lots_obj = new_draw_lots_obj
                position = 0
                draw_lots_list = [int(i) for i in draw_lots_obj.draw_lots_user_ids.split(',')]
            print(day, position, draw_lots_list, pre_position, day_list)
            if parse(day) == end_day and pre_position > 0:
                position, user_id = self.get_next_draw_lots_id(draw_lots_list, pre_position)
            else:
                position, user_id = self.get_next_draw_lots_id(draw_lots_list, position)
            position += 1
            user_obj = Users.objects.filter(id=user_id).first()
            if not user_obj:
                print("user not found")
                return {}
            result.append(callback_func(day, user_obj))
        return result

    def get_history_list(self, days):
        result = []
        pre_position = 0
        for day in days:
            day_obj = parse("%s %s" % (day, "00:00:00"))
            obj = OnCallSchedule.objects.filter(on_call_date=day_obj).first()
            if obj:
                pre_position += 1
                result.append(self.gen_oncall_info(obj, day_obj.strftime("%Y-%m-%d")))
                continue

            draw_lots_obj = None
            draw_lots_start_day = ""
            draw_lots_user_id = 0

            history_last_user_on_call_obj = OnCallSchedule.objects.filter(
                on_call_date__lte=day_obj,
                type=0
            ).order_by("on_call_date").last()

            if not history_last_user_on_call_obj:
                draw_lots_obj = DrawLots.objects.filter(
                    effective_date__lte=day_obj
                ).order_by("effective_date").last()
                draw_lots_user_id = int(draw_lots_obj.draw_lots_user_ids.split(',')[-1])
                draw_lots_start_day = draw_lots_obj.effective_date
            else:
                draw_lots_obj = DrawLots.objects.filter(
                    effective_date__lte=history_last_user_on_call_obj.on_call_date
                ).order_by('effective_date').last()
                draw_lots_start_day = history_last_user_on_call_obj.on_call_date
                draw_lots_user_id = history_last_user_on_call_obj.user.id

            if draw_lots_obj:
                draw_lots_user_ids = [int(i) for i in draw_lots_obj.draw_lots_user_ids.split(',')]
                on_call_data = self.calculate_engine(
                    draw_lots_obj=draw_lots_obj,
                    history_start_day=draw_lots_start_day,
                    end_day=day_obj,
                    draw_lots_list=draw_lots_user_ids,
                    start_lots_id=draw_lots_user_id,
                    callback_func=self.calculate_history_data,
                    pre_position=pre_position
                )

                for i in on_call_data:
                    if i["date"] in days and i not in result:
                        result.append(i)
                pre_position = 0
        return result

    def get_future_list(self, days):
        result = []
        pre_position = 0

        for day in days:
            day_obj = parse("%s %s" % (day, "00:00:00"))
            obj = OnCallSchedule.objects.filter(on_call_date=day_obj, type=1).first()
            if obj:
                pre_position += 1
                result.append(self.gen_oncall_info(obj, day_obj.strftime("%Y-%m-%d")))
                continue

            oncall_user_obj = OnCallSchedule.objects.filter(
                on_call_date__lte=day_obj
            ).order_by("on_call_date").last()

            draw_lots_obj = DrawLots.objects.filter(
                effective_date__lte=oncall_user_obj.on_call_date
            ).order_by('effective_date').last()

            start_day = oncall_user_obj.on_call_date
            history_last_user_id = oncall_user_obj.user.id

            draw_user_ids = [int(i) for i in draw_lots_obj.draw_lots_user_ids.split(',')]
            on_call_data = self.calculate_engine(
                draw_lots_obj=draw_lots_obj,
                history_start_day=start_day,
                end_day=day_obj,
                draw_lots_list=draw_user_ids,
                start_lots_id=history_last_user_id,
                callback_func=self.calculate_future_data,
                pre_position=pre_position
            )
            for i in on_call_data:
                if i["date"] in days and i not in result:
                    result.append(i)
            pre_position = 0

        return result

    @staticmethod
    def merge_oncall_list(history, future):
        history.extend(future)
        return history

    def on_call_list(self):
        days = self.get_month_dates(self.month)
        today = parse(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))

        history_days = []
        future_days = []

        for day in days:
            day_obj = parse("%s %s" % (day, "00:00:00"))
            if today > day_obj:
                history_days.append(day)
            else:
                future_days.append(day)
        history = self.get_history_list(history_days)
        future = self.get_future_list(future_days)
        return self.merge_oncall_list(history, future)


class OncallManager:

    def __init__(self):
        self.limit = 3

    @staticmethod
    def draw_lots(user_ids: [int], effective_date: str) -> (bool, str):
        effective_date = "%s 00:00:00" % effective_date
        obj = DrawLots.objects.filter(effective_date=effective_date)
        if obj:
            return False, "The current time has been drawn"

        for user_id in user_ids:
            user_obj = Users.objects.filter(id=user_id).first()
            if not user_obj:
                return False, "user_id: %d does not exist" % user_id

        today = parse(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))
        effective_date = parse(effective_date)
        if today > effective_date:
            return False, "The effective time is not allowed to be greater than the current time"

        random.shuffle(user_ids)

        s = ",".join([str(i) for i in user_ids])
        DrawLots(
            draw_lots_user_ids=s,
            effective_date=effective_date
        ).save()
        return True, "Lottery completed"

    @staticmethod
    def update_oncall_table(date: str, user_id: int) -> (bool, str):
        user_obj = Users.objects.filter(id=user_id).first()
        if not user_obj:
            return False, "user not found"
        date = "%s 00:00:00" % date
        today = parse(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))
        date = parse(date)
        if today >= date:
            return False, "The effective time is not allowed to be greater than the current time"

        sched_obj = OnCallSchedule.objects.filter(
            on_call_date=date
        ).first()

        if sched_obj:
            sched_obj.user = user_obj
            sched_obj.type = 1
            sched_obj.save()
        else:
            OnCallSchedule(
                user=user_obj,
                on_call_date=date,
                type=1
            ).save()
        return True, ""

    def get_oncall_list(self, date: str):
        sched = scheduler(date)
        return sched.on_call_list()

    @staticmethod
    def reset_future(date: str) -> (bool, str):
        date = "%s 00:00:00" % date
        today = parse(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))
        date = parse(date)
        if today >= date:
            return False, "The effective time is not allowed to be greater than the current time"
        sched_obj = OnCallSchedule.objects.filter(
            on_call_date=date
        ).first()
        if sched_obj:
            sched_obj.delete()
        return True, ""

    @staticmethod
    def get_user_list(out_params: dict):
        in_params = {
            "phone": "phone",
            "username": "username__icontains",
            "name": "name__icontains",
            "email": "email__icontains"
        }
        params = {}
        for k, v in out_params.items():
            if in_params.get(k, None) is not None:
                params[in_params[k]] = v
        result = []
        users = Users.objects.filter(**params)
        for user in users:
            t = {
                "user_id": user.id,
                "username": user.username,
                "name": user.name,
                "email": user.email,
                "phone": user.phone,
                'create_time': user.create_time.strftime('%Y-%m-%d %H:%M:%S')
            }
            result.append(t)
        return result

    @staticmethod
    def create_user(params: dict) -> (int, str):
        required_params = [
            "phone",
            "username",
            "name",
            "email"
        ]
        for i in required_params:
            if i not in params.keys():
                return 400, "无效的参数"
        try:
            params["phone"] = int(params["phone"])
        except Exception as e:
            return 400, str(e)

        if len(str(params['phone'])) != 11:
            return 400, "手机长度不正确"

        user = Users.objects.filter(username=params["username"]).first()
        if user:
            return 400, "用户已存在"
        try:
            Users(
                username=params["username"],
                name=params["name"],
                email=params["email"],
                phone=params["phone"]
            ).save()
        except django.db.Error as e:
            return 500, str(e)
        return 200, "success"

    @staticmethod
    def delete_user(user_id: int) -> bool:
        user = Users.objects.filter(id=user_id).first()
        if user:
            user.delete()
        return True
